package main

import (
	"fmt"
)

/*
 【GoRoutineまとめ】
 ・GoRoutine: プログラム内で複数の処理を同時に実行する（並列処理を行う）ための仕組み
   => 書式は通常の関数と同じで、呼び出し方法によって通常の関数か、GoRoutineとして使用するかが変わる。
      go test() のような形で関数の呼び出し前に go と指定すると新たなGoRoutineとして動作を開始する。

 ・通常の関数と大きく異なる点は、GoRoutineとして起動した関数に関してはその終了を待たないので、そのままでは戻り値を返しても受け取ることができない。

 ・同時に処理を複数行うにはスレッドも複数必要だが、2021年11月時点ではGo言語のランタイムはデフォルトでスレッドを1つしか使用しない。
   また、プログラム起動時にランタイムが暗黙的にGoRoutineを1つ作成し、そこでmain関数を実行するため、メインのGoRoutineが終了すると
   他のGoRoutineが起動中であってもプログラムが終了してしまう。
   => 起動したGoRoutineの終了待ちが必要な時や、GoRoutineの処理結果を受け取るときはチャネルを使用する。
      また、ランタイム時に使用するスレッド数を変更する場合は、環境変数「GOMAXPROCS」に使用する最大スレッド数を設定する。(将来的には自動的に複数スレッドを使用できるようになる予定)

 ・1つのスレッドしかない状態で複数のGoRoutineがある場合、Go言語のランタイムのスケジューラ機能によって、1つのGoRoutineが中断したら、
   今まで一時中断していた別のGoRoutineが動作を再開するといった形で見かけ上の並列処理が行われる。
   => 実行中のGoRoutineを必要に応じて一時中断させ、他のGoRoutineの実行を再開させるためにruntimeパッケージのGosched関数を呼び出すこともできるが、
      基本的にはランタイムに任せることが推奨されている。

 ・チャネル: Go言語プログラム内での通信機構で、GoRoutine間における「通信」「同期」「値の共用」に使用する。
           チャネルで通信できるのは同一プログラム内だけで、Go言語で作られたプログラムであっても、別々に
		   実行されたプログラム間でのチャネル通信はできない。

 ・チャネル型の書式: 送受信可能なチャネル型の値を送信専用、または受信専用のチャネルの型の変数に代入することはできるが、逆はできない。
     -- chan 要素型
	 -- chan <- 要素型  // 送信専用チャネル型
	 -- <- chan 要素型  // 受信専用チャネル型

 ・チャネルの作成: スライスやマップと同じく参照型であるため、値の作成にはmake関数を用いる。
     -- make(chan 要素型, キャパシティ)
	 -- make(chan 要素型)

 ・チャネルへの値の送受信
     -- チャネル <- 送信する値  // 送信
	 -- <- チャネル           // 受信

 ・チャネルのクローズ: 使用しなくなったチャネルはclose関数を使用してクローズする。ただし、受信専用チャネルはクローズできない。
                    クローズ済みのチャネルへ値を送信することもできないが、受信はできる。その場合、クローズ直前までに送信されて
					チャネルでバッファリングされている値がなくなるまで受信できる。
     -- close(チャネル)

 ・チャネルに対してcap関数を使うことでキャパシティの値が取得でき、len関数を使うことでバッファリングされている要素数を取得できる。
*/
func main() {

	// チャネルの作成
	c := make(chan int)

	// 関数リテラルを使いGoRoutineを起動。この関数のパラメータは送信専用チャネル
	go func(s chan<- int) {

		fmt.Println("GoRoutine開始")

		// チャネルへ0~4への値を順番に送信
		for i := 0; i < 5; i++ {
			s <- i
		}

		// チャネルのクローズ
		close(s)
	}(c)

	// 受信ループ
	for {

		// チャネルからの受信
		// クローズされたか判定する必要がなければ2番目の値は受け取る必要はない
		value, ok := <-c

		// チャネルがクローズされるとokにfalseが返される
		if !ok {
			break
		}

		// 受信した値を出力
		fmt.Println(value)
	}
}
