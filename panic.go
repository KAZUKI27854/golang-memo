package main

import "fmt"

/*
 【パニックとリカバリによるエラーハンドリング】
 ・panic関数
   => 致命的なエラーのため呼び出し元でエラーハンドリングさせる必要がない、もしくはエラーが起きても
      本当にリカバリが必要な時だけエラーハンドリングさせたい場合に使い、「パニック」という状態を発生させる。

 ・パニック状態
   => ある関数内でpanic関数を呼び出すと、その関数の実行はすぐに中断され、呼び出し元に復帰する。
      呼び出し元に復帰後も、あたかもそこでpanic関数が呼び出されたかのように順次関数の呼び出しをさかのぼっていき、
	  最終的にプログラム自体が終了する。パニック状態となってプログラムが終了するとpanic関数に渡されたパラメータの値とともに
	  パニックの発生箇所が出力される。

 ・リカバリ
   => recover関数を呼び出すことで、パニックにより関数呼び出しをさかのぼっていく処理を中断させることができる。
      recover関数からの戻り値は、panic関数に与えられたパラメータで、パニック状態でない時はその値がnilとなるので、
	  それによってパニック状態かどうかを判断する。
	  また、recover関数を呼び出すことができるのはdefer文によって遅延指定された関数だけという点に注意が必要。

   -- func recover() interface{}

 ・defer文によって遅延指定された関数があれば、その関数はパニック時でも実行される。

 ・ランタイムパニック
   => 配列のインデックスに範囲外の値を指定した時など、Go言語のランタイムがパニックを起こすこともある。
      これをランタイムパニックと呼び、この時のpanic関数のパラメータには「runtime.Errorインターフェース型」の値が渡される。

 ・環境変数「GOTRACEBACK」の指定によって、リカバリされなかったパニックや予期しないランタイムエラー発生時のエラー出力を制御できる。
*/
func main() {

	panicFunc(false)
	panicFunc(true)
}

func panicFunc(p bool) {
	
	fmt.Println(p, "の場合")

	// 遅延指定された関数内でrecover関数を呼び出す
	defer func() {

		fmt.Println("遅延関数開始")

		// リカバリ
		if err := recover(); err != nil {
			fmt.Println("リカバリによるパニック中断: ", err)
		}

		fmt.Println("遅延関数終了")
	}()

	if p {
		// パニック関数
	    panic("パニック発生")
	}
}